package space.invaders.pkg;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.Iterator;
import javax.swing.JPanel;
import javax.swing.Timer;

// a tela possui 550 de largura por 500 de altura
public class janelaJogo5 extends javax.swing.JFrame implements ActionListener{

    private final int miliseconds = 4;
    
    private Timer timer;

    public boolean isDificuldadeNormal;
    public boolean isPausado;
    private boolean atirar;
    private int movimento;
    private int tempoEntreDisparosJogador;

    private naveJogador jogador;
    private ArrayList<disparo> vetorDisparos = new ArrayList<>();
    private ArrayList<barreira> linhaDeDefesa = new ArrayList<>();
    
    public janelaJogo5(menuInicial mu) {
        initComponents();
        this.setVisible(true);
        this.setLocationRelativeTo(null);
        this.setResizable(false);
        this.setFocusable(true);
        
        this.PausadoLabel.setVisible(false);
        this.isDificuldadeNormal = mu.isDificuldadeNormal;
        this.isPausado = false;
        
        criaJogador();
        criaBarreiras();
        
        PainelJogo.setVisible(true);
        
        timer = new Timer(miliseconds, this);
        timer.start();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        PainelJogo = pinta();
        ScoreLabel = new javax.swing.JLabel();
        PausadoLabel = new javax.swing.JLabel();
        VidasLabel = new javax.swing.JLabel();
        ValorLabel = new javax.swing.JLabel();
        QtdVidasLabel = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        addKeyListener(new java.awt.event.KeyAdapter() {
            @Override
            public void keyPressed(java.awt.event.KeyEvent evt) {
                formKeyPressed(evt);
            }
            @Override
            public void keyReleased(java.awt.event.KeyEvent evt) {
                formKeyReleased(evt);
            }
        });

        javax.swing.GroupLayout PainelJogoLayout = new javax.swing.GroupLayout(PainelJogo);
        PainelJogo.setLayout(PainelJogoLayout);
        PainelJogoLayout.setHorizontalGroup(
            PainelJogoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        PainelJogoLayout.setVerticalGroup(
            PainelJogoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 500, Short.MAX_VALUE)
        );

        ScoreLabel.setText("Score:");

        PausadoLabel.setText("PAUSADO");

        VidasLabel.setText("Vidas:");

        ValorLabel.setText("valor");

        QtdVidasLabel.setText("qtd");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(PainelJogo, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(ScoreLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(ValorLabel)
                .addGap(136, 136, 136)
                .addComponent(PausadoLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 139, Short.MAX_VALUE)
                .addComponent(VidasLabel)
                .addGap(18, 18, 18)
                .addComponent(QtdVidasLabel)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(0, 15, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(ScoreLabel)
                    .addComponent(PausadoLabel)
                    .addComponent(VidasLabel)
                    .addComponent(ValorLabel)
                    .addComponent(QtdVidasLabel))
                .addGap(18, 18, 18)
                .addComponent(PainelJogo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pack();
    }// </editor-fold>                                                       

    private void formKeyPressed(java.awt.event.KeyEvent evt) 
    {                                
        int tecla = evt.getKeyCode();

        switch (tecla) {
            case KeyEvent.VK_A:
                movimento = -1;
                break;
            case KeyEvent.VK_D:
                movimento = 1;
                break;
            case KeyEvent.VK_SPACE:
                
                if(this.tempoEntreDisparosJogador <= 0)
                {
                    atirar = true;
                    this.tempoEntreDisparosJogador = 1500 / miliseconds ;
                    // novo disparo a cada 2.5 segundos
                }
                
                break;
            case KeyEvent.VK_P:
                
                PausadoLabel.setVisible(true);
                this.isPausado = true;
                menuPausa mp = new menuPausa(this);
                break;
            default:
                break;
        }
    }    
    
    private void formKeyReleased(java.awt.event.KeyEvent evt) {                                 
        int tecla = evt.getKeyCode();

        switch (tecla) 
        {
            case KeyEvent.VK_A:
                movimento = 0;
                break;
            case KeyEvent.VK_D:
                movimento = 0;
                break;
            default:
                break;
        }
    } 

    public void actionPerformed(ActionEvent e) {
        // as operações de movimentação e tiro só são realizadas quando o jogo não está pausado
        if(!isPausado)
        {
            jogador.movimento(movimento,true); // movimentação do jogador. Ocorre de acordo com o valor determinado em "movimento".
            if(this.atirar)// o jogador dispara se essa flag for verdadeira
            {                                             // assim o disparo sai do meio da bave
                vetorDisparos.add(new disparo(jogador.x + 20, jogador.y, -1));
                this.atirar = false;
                // 1 pois o disparo irá pra cima
            }
            else
            {
                this.tempoEntreDisparosJogador--;
            }


            // movimentar inimigos

            movimentarDisparos();
            colisaoBarreiras();
            // verificar colisao com os outros objetos






            // a repintura do painel precisa ser a última operação a ser feita
            PainelJogo.repaint();
        }
        
        
        
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(janelaJogo4.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(janelaJogo4.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(janelaJogo4.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(janelaJogo4.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new janelaJogo5(null).setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify                     
    private javax.swing.JPanel PainelJogo;
    public javax.swing.JLabel PausadoLabel;
    private javax.swing.JLabel QtdVidasLabel;
    private javax.swing.JLabel ScoreLabel;
    private javax.swing.JLabel ValorLabel;
    private javax.swing.JLabel VidasLabel;
    // End of variables declaration                   

    public JPanel pinta()
    {
        JPanel painel;
        painel = new JPanel()
        {
            @Override
            public void paint(Graphics g){
                g.setColor(Color.blue);
                Graphics2D imagens = (Graphics2D) g;
                imagens.fillRect(0, 0, 550, 500);   // preenche o fundo 
                imagens.drawImage(jogador.getImagem(), jogador.x, jogador.y, this); // desenha o jogador
                for(disparo d : vetorDisparos)// desenha os disparos (jogador e inimigos)
                {
                    imagens.drawImage(d.getImagem(), d.x, d.y, this);
                }
                
                for(barreira b: linhaDeDefesa)
                {
                    Rectangle[][] mat = b.getMatriz();
                    
                    for(int i = 0; i < b.getQtdBlocosAltura(); i++)
                    {
                        for(int j = 0; j < b.getQtdBlocosLargura(); j++)
                        {
                            if(mat[i][j] == null)// o null indica que aquela posição não existe mais, logo não é desenhada
                                continue;
                                
                            imagens.drawImage(b.getImagem(), mat[i][j].x,mat[i][j].y, this);    
                        }
                    }
                }

                // desenhar naves inimigas
                // desenhar nave especial
                
                
                g.dispose();
            }
        };
                
        return painel;
    }
    
    public void movimentarDisparos()
    {       
        boolean r;
        
        for (Iterator iterador = vetorDisparos.iterator(); iterador.hasNext();) 
        {
            disparo n = (disparo) iterador.next();
            
            r = n.movimentarVertical();
            if(r)
            {
                iterador.remove();
            }
            
        }
    }
    
    public void colisaoBarreiras()
    {
        //primeiramente é verificado, para cada disparo, se ocorre uma colisão com a barreira em um todo
        
        for(Iterator iterador = vetorDisparos.iterator(); iterador.hasNext();)
        {
            disparo d = (disparo) iterador.next();
            for(Iterator iter = linhaDeDefesa.iterator(); iter.hasNext();)
            {
                barreira b = (barreira) iter.next();
                if(d.intersects(b))
                {
                    // sabendo que realmente ocorre uma colisão, chamamos a função que realiza a colisão interna (se ocorrer)
                    if(b.colisao(d))
                    {
                        // ocorreu uma colisao, entao eliminamos o disparo
                        iterador.remove(); // remove o disparo
                        
                        if(b.barreiraTotalmenteDestruida())
                        {
                            //caso a barreira esteja totalmente destruída, eliminamos ela da lista de barreiras
                            iter.remove();
                        }
                        
                        break;// como o disparo que estava sendo verificado já colidiu,não precisamos verificar o resto das barreiras
                    }
                }
            }
        }
    }
    
    public void criaJogador()
    {
        // sao 550 de largura, o meio entao seria em 275. Porém o jogador tem 40 pixels de largura, logo pra ser no meio precisamos diminuir 20.
        // sao 500 de altura. A linha mais embaixo é a 499. Tiramos 40 pois sao 30 da altura do jogador e 10 de espaço no fundo.
        jogador = new naveJogador(255, 459, 40, 30);
        this.atirar = false;
        this.movimento = 0;
        this.tempoEntreDisparosJogador = 0;
        this.atirar = false;

    }
    
    
    public void criaBarreiras()
    {
        barreira nova;
        int coordenadaX = 70; // começa em 70
        int coordenadaY = 380; // 500 - 10 - 30 - 30 - 50
        
        for(int i = 0; i < 5; i++)
        {
            // 90px separam a ponta esquerda superior de duas barreiras.
            nova = new barreira(coordenadaX + 90 * i,coordenadaY);
            
            linhaDeDefesa.add(nova);
            
        }
    }
}

// --- Horizontal / Barreiras ---//
// Sao 550 pixels
// 70px 50px 40px 50px 40px 50px 40px 50px 40px 50px 70px
//  E    B    E    B    E    B    E    B    E    B    E

// --- Vertical --- //
    // zona de controle do inimigo --> 350 pixels
// 10 pixels de espaço
// 20 pixels da nave de evento especial
// 50 pixels de espaço
// 270 pixels para as fileiras inimigas se movimentarem

    // zona de controle do jogador --> 150 pixels
// 30 pixels de espaço
// 50 pixels de barreira.
// 30 pixels de espaço.
// 30 pixels do jogador.
// 10 pixels de espaço.