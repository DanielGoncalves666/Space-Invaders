package jogo;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.Timer;

// a tela possui 550 de largura por 500 de altura
public class janelaJogoFinal extends javax.swing.JFrame implements ActionListener{

    private final int miliseconds = 4;// padrao é 4
    private final int IntervaloEntreDisparosInimigos = 1000 / miliseconds;   
    private final int IntervaloMovimento = 10;
    private final int IntervaloMovimentoEspecial = 5;
    private final int eventoEspecial = 9; // a cada 9 naves destruidas uma nave especial aparece
    
    private Timer timer;

    public boolean isDificuldadeNormal;
    public boolean isPausado;
    public boolean jogadorFoiDestruido;
    public boolean recomecar;
    private boolean atirar;
    private int movimento;
    private int IntervaloMovimentoInimigo;
    private int IntervaloMovimentoInimigoEspecial;
    private int contagemEntreDisparos;
    private int qtdVidas;
    private int Score;
    private int contagemEventoEspecial;
    private int velMovHorizontalInimigo;

    private naveJogador jogador;
    private ArrayList<disparo> vetorDisparos = new ArrayList<>();
    private ArrayList<barreira> linhaDeDefesa = new ArrayList<>();
    private frotaInimiga Frota;
    private naveInimigaEspecial especial;
    
    public janelaJogoFinal(menuInicial mu) {
        initComponents();
        this.setLocationRelativeTo(null);
        this.setVisible(true);
        this.setResizable(false);
        this.setFocusable(true);
        this.setTitle("Space Invaders");
        
        this.PausadoLabel.setVisible(false);
        this.isDificuldadeNormal = mu.isDificuldadeNormal;
        this.isPausado = false;
        
        criaJogador();
        criarInimigos();

        if(isDificuldadeNormal) // barreiras apenas na dificuldade normal
        {
            criaBarreiras();
            this.velMovHorizontalInimigo = 2;
        }
        else
        {
            this.velMovHorizontalInimigo = 4;
        }

        
        PainelJogo.setVisible(true);
        
        timer = new Timer(miliseconds, this);
        timer.start();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        PainelJogo = pinta();
        ScoreLabel = new javax.swing.JLabel();
        PausadoLabel = new javax.swing.JLabel();
        VidasLabel = new javax.swing.JLabel();
        ValorLabel = new javax.swing.JLabel();
        QtdVidasLabel = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        addKeyListener(new java.awt.event.KeyAdapter() {
            @Override
            public void keyPressed(java.awt.event.KeyEvent evt) {
                formKeyPressed(evt);
            }
            @Override
            public void keyReleased(java.awt.event.KeyEvent evt) {
                formKeyReleased(evt);
            }
        });

        javax.swing.GroupLayout PainelJogoLayout = new javax.swing.GroupLayout(PainelJogo);
        PainelJogo.setLayout(PainelJogoLayout);
        PainelJogoLayout.setHorizontalGroup(
            PainelJogoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        PainelJogoLayout.setVerticalGroup(
            PainelJogoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 500, Short.MAX_VALUE)
        );

        ScoreLabel.setText("Score:");

        PausadoLabel.setText("PAUSADO");

        VidasLabel.setText("Vidas:");

        ValorLabel.setText("valor");

        QtdVidasLabel.setText("qtd");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(PainelJogo, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(ScoreLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(ValorLabel)
                .addGap(136, 136, 136)
                .addComponent(PausadoLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 139, Short.MAX_VALUE)
                .addComponent(VidasLabel)
                .addGap(18, 18, 18)
                .addComponent(QtdVidasLabel)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(0, 15, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(ScoreLabel)
                    .addComponent(PausadoLabel)
                    .addComponent(VidasLabel)
                    .addComponent(ValorLabel)
                    .addComponent(QtdVidasLabel))
                .addGap(18, 18, 18)
                .addComponent(PainelJogo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pack();
    }// </editor-fold>                                                       

    private void formKeyPressed(java.awt.event.KeyEvent evt) 
    {
        int tecla = evt.getKeyCode();
        this.recomecar = true;
        
        switch (tecla) {
            case KeyEvent.VK_LEFT:
                movimento = -1;
                break;
            case KeyEvent.VK_RIGHT:
                movimento = 1;
                break;
            case KeyEvent.VK_SPACE:
                if(!isJogadorDisparado())    
                    this.atirar = true;
                break;
            case KeyEvent.VK_P:
                
                PausadoLabel.setVisible(true);
                this.isPausado = true;
                menuPausa mp = new menuPausa(this);
                break;
            default:
                break;
        }
    }    
    
    private void formKeyReleased(java.awt.event.KeyEvent evt) {                                 
        int tecla = evt.getKeyCode();

        switch (tecla) 
        {
            case KeyEvent.VK_LEFT:
                movimento = 0;
                break;
            case KeyEvent.VK_RIGHT:
                movimento = 0;
                break;
            default:
                break;
        }
    } 

    @Override
    public void actionPerformed(ActionEvent e) {
        // as operações de movimentação e tiro só são realizadas quando o jogo não está pausado
        if(this.jogadorFoiDestruido)
        {
            repaint();
            if(this.recomecar)
            {
                this.jogadorFoiDestruido = false;
                jogador = new naveJogador(255, 459, 40, 30);
            }
        } 
        else if(!isPausado)
        {

            jogador.movimento(movimento,true); // movimentação do jogador. Ocorre de acordo com o valor determinado em "movimento".
            if(this.atirar) // disparo do jogador
            {                                             // assim o disparo sai do meio da nave
                vetorDisparos.add(new disparo(jogador.x + 20, jogador.y, -1));
                this.atirar = false;
                // -1 pois o disparo irá pra cima
            }
            
            if(naveInimigaPodeDisparar()) // disparo do inimigo
            {
                disparo d;
                if((d = Frota.disparar(jogador)) != null)
                {
                    vetorDisparos.add(d);
                }
            }
            
            // movimentação do inimigo
            if(IntervaloMovimentoInimigo == 0)
            {
                Frota.moverFrota(this.velMovHorizontalInimigo, 5);
                IntervaloMovimentoInimigo = IntervaloMovimento;
            }
            else
            {
                IntervaloMovimentoInimigo--;
            }
            // movimentação do inimigo
            
            
            if(isDificuldadeNormal) // barreiras disponíveis apenas no modo normal
            {    // barreiras somem
                if(Frota.LinhaNaveMaisBaixa() + 20 >= 339)
                {

                    for (Iterator iterador = linhaDeDefesa.iterator(); iterador.hasNext();) 
                    {    
                        barreira b = (barreira) iterador.next();
                        iterador.remove();
                    }
                }
                // barreiras somem
            }  
                
            // so cria a nave se o requerimento de evento foi completo e n tiver nenhuma ja criada
            if(contagemEventoEspecial == 0 && especial == null)
            {
                criarNaveEspecial();               
            }
            
            if(especial != null)//movimento e eliminação da nave especial
            {
                if(this.IntervaloMovimentoInimigoEspecial == 0)
                {
                    boolean t = especial.moverDireita(1);
                    if(!t)
                    {
                        // nave chegou no canto direito
                        this.eliminarNaveEspecial();
                    }
                    this.IntervaloMovimentoInimigoEspecial = IntervaloMovimentoEspecial;
                }
                else
                {
                    this.IntervaloMovimentoInimigoEspecial--;
                }
            }
            
            movimentarDisparos();
            if(isDificuldadeNormal) // barreiras apenas na dificuldade normal
                colisaoBarreiras();
            colisaoFrotaInimiga();
            colisaoNaveEspecial();
            boolean colidiu = colisaoJogador();

            if(colidiu)
            {
                this.jogadorFoiDestruido = true;
                this.recomecar = false;
                jogador.setImagem("imagens/Explosao.gif");   
                this.QtdVidasLabel.setText(qtdVidas + "");
            }
            
            if(qtdVidas == 0 || Frota.LinhaNaveMaisBaixa() >= 460)
            {
                // nesses casos o jogo acaba
                this.isPausado = true;
                JOptionPane.showMessageDialog(null, "Suas vidas acabaram. Fim de jogo!", "Que pena!", JOptionPane.ERROR_MESSAGE);
                this.dispose();
            }

            if(Frota.getTotalVivas() == 0)
            {
                this.isPausado = true;
                JOptionPane.showMessageDialog(null, "Você venceu!", "Score: " + Score, JOptionPane.ERROR_MESSAGE);
                this.dispose();
            }
        
            ValorLabel.setText(this.Score + "");
            PainelJogo.repaint();// a repintura do painel precisa ser a última operação a ser feita
        }
        
        
        
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(janelaJogoFinal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(janelaJogoFinal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(janelaJogoFinal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(janelaJogoFinal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new janelaJogoFinal(null).setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify                     
    private javax.swing.JPanel PainelJogo;
    public javax.swing.JLabel PausadoLabel;
    private javax.swing.JLabel QtdVidasLabel;
    private javax.swing.JLabel ScoreLabel;
    private javax.swing.JLabel ValorLabel;
    private javax.swing.JLabel VidasLabel;
    // End of variables declaration                   

    public JPanel pinta()
    {
        JPanel painel;
        painel = new JPanel()
        {
            @Override
            public void paint(Graphics g){
                g.setColor(Color.blue);
                Graphics2D imagens = (Graphics2D) g;
                imagens.fillRect(0, 0, 550, 500);   // preenche o fundo 
                imagens.drawImage(jogador.getImagem(), jogador.x, jogador.y, this); // desenha o jogador
                for(disparo d : vetorDisparos)// desenha os disparos (jogador e inimigos)
                {
                    imagens.drawImage(d.getImagem(), d.x, d.y, this);
                }
                
                for(barreira b: linhaDeDefesa) //desenha as linhas de defesa
                {
                    Rectangle[][] mat = b.getMatriz();
                    
                    for(int i = 0; i < b.getQtdBlocosAltura(); i++)
                    {
                        for(int j = 0; j < b.getQtdBlocosLargura(); j++)
                        {
                            if(mat[i][j] == null)// o null indica que aquela posição não existe mais, logo não é desenhada
                                continue;
                                
                            imagens.drawImage(b.getImagem(), mat[i][j].x,mat[i][j].y, this);    
                        }
                    }
                }
                
                
                HashMap<Integer,naveInimiga> inimigos = Frota.getFleet();
                Object[] vet = inimigos.keySet().toArray();
                for(Object key : vet) //desenha a frota inimiga
                {
                    naveInimiga ni = inimigos.get((Integer) key);
                    
                    imagens.drawImage(ni.getImagem(), ni.x, ni.y, this);
                }
                
                if(especial != null)// desenha a nave especial
                {
                    imagens.drawImage(especial.getImagem(), especial.x, especial.y, this);
                }
                
                g.dispose();
            }
        };
                
        return painel;
    }
    
    public void movimentarDisparos()
    {       
        boolean r;
        
        for (Iterator iterador = vetorDisparos.iterator(); iterador.hasNext();) 
        {
            disparo n = (disparo) iterador.next();
            
            if(n.getModificadorDeDirecao() == 1)
            {
                // disparos do inimigo
                r = n.movimentarVertical(1);
            }
            else
            {
                r = n.movimentarVertical(2);
            }
            
            if(r)
            {
                iterador.remove();
            }
            
        }
    }
    
    public void colisaoBarreiras()
    {
        //primeiramente é verificado, para cada disparo, se ocorre uma colisão com a barreira em um todo
        
        for(Iterator iterador = vetorDisparos.iterator(); iterador.hasNext();)
        {
            disparo d = (disparo) iterador.next();
            for(Iterator iter = linhaDeDefesa.iterator(); iter.hasNext();)
            {
                barreira b = (barreira) iter.next();
                if(d.intersects(b))
                {
                    // sabendo que realmente ocorre uma colisão, chamamos a função que realiza a colisão interna (se ocorrer)
                    if(b.colisao(d))
                    {
                        // ocorreu uma colisao, entao eliminamos o disparo
                        iterador.remove(); // remove o disparo
                        
                        if(b.barreiraTotalmenteDestruida())
                        {
                            //caso a barreira esteja totalmente destruída, eliminamos ela da lista de barreiras
                            iter.remove();
                        }
                        
                        break;// como o disparo que estava sendo verificado já colidiu,não precisamos verificar o resto das barreiras
                    }
                }
            }
        }
    }
    
    public void colisaoFrotaInimiga()
    {
        int score;
        
        for(Iterator iterador = vetorDisparos.iterator(); iterador.hasNext();)
        {
            disparo d = (disparo) iterador.next();
            
            if(d.intersects(Frota))
            {
                // possivel colisao com uma nave inimiga
                score = Frota.colisao(d);
                
                if(score != 0)
                {
                    this.Score += score;
                    this.contagemEventoEspecial--;
                    iterador.remove();
                }
            }
        }
        
            
    }
    
    public boolean colisaoJogador()
    {
        for(Iterator iterador = vetorDisparos.iterator(); iterador.hasNext();)
        {
            disparo d = (disparo) iterador.next();
            
            if(d.getModificadorDeDirecao() == 1)
            {
                if(d.intersects(jogador))
                {
                    iterador.remove();
                    this.qtdVidas--; 
                    
                    return true;
                }
            }
        }
        
        return false;
    }
    
    public void colisaoNaveEspecial()
    {
        if(especial != null) // verifica colisão apenas se uma nave especial existir
        {
            for(Iterator iterador = vetorDisparos.iterator(); iterador.hasNext();)
            {
                disparo d = (disparo) iterador.next();
                
                if(d.intersects(especial))
                {
                    // nave especial atingida
                    this.Score += especial.getScore();
                    eliminarNaveEspecial();
                    iterador.remove();
                    break;
                }
            }
        }
    }
    
    public boolean isJogadorDisparado()
    {
        for(Iterator iterador = vetorDisparos.iterator(); iterador.hasNext();)
        {
           disparo d = (disparo) iterador.next();
           
           if(d.getModificadorDeDirecao() == -1)
           {
               return true;
           }
        }
        
        return false;
    }
    
    public boolean naveInimigaPodeDisparar()
    {
        int qtd = 0;
        
        for(Iterator iterador = vetorDisparos.iterator(); iterador.hasNext();)
        {
           disparo d = (disparo) iterador.next();
           
           if(d.getModificadorDeDirecao() == 1)
           {
               qtd++;
           }
        }
        
        if(qtd == 3 || contagemEntreDisparos > 0)
        {
            contagemEntreDisparos--;
            return false;
        }
        else
        {
            contagemEntreDisparos = IntervaloEntreDisparosInimigos;
            return true;
        }
    }
    
    public void criaJogador()
    {
        // sao 550 de largura, o meio entao seria em 275. Porém o jogador tem 40 pixels de largura, logo pra ser no meio precisamos diminuir 20.
        // sao 500 de altura. A linha mais embaixo é a 499. Tiramos 40 pois sao 30 da altura do jogador e 10 de espaço no fundo.
        jogador = new naveJogador(255, 459, 40, 30);
        this.atirar = false;
        this.movimento = 0;
        this.qtdVidas = 3;
        this.QtdVidasLabel.setText(qtdVidas + "");
        this.Score = 0;
        this.jogadorFoiDestruido = false;
        this.ValorLabel.setText(Score + "");

    }
    
    
    public void criaBarreiras()
    {
        barreira nova;
        int coordenadaX = 70; // começa em 70
        int coordenadaY = 380; // 500 - 10 - 30 - 30 - 50
        
        for(int i = 0; i < 5; i++)
        {
            // 90px separam a ponta esquerda superior de duas barreiras.
            nova = new barreira(coordenadaX + 90 * i,coordenadaY);
            
            linhaDeDefesa.add(nova);
            
        }
    }
    
    public void criarInimigos()
    {
        Frota = new frotaInimiga();
        IntervaloMovimentoInimigo = 0;
        contagemEntreDisparos = 0;
        contagemEventoEspecial = eventoEspecial;
    }
    
    public void criarNaveEspecial()
    {
        especial = new naveInimigaEspecial();
        this.IntervaloMovimentoInimigoEspecial = this.IntervaloMovimentoEspecial;
    }
    
    public void eliminarNaveEspecial()
    {
        especial = null;
        contagemEventoEspecial = eventoEspecial;
    }
}

// --- Horizontal / Barreiras ---//
// Sao 550 pixels
// 70px 50px 40px 50px 40px 50px 40px 50px 40px 50px 70px
//  E    B    E    B    E    B    E    B    E    B    E

// --- Vertical --- //
    // zona de controle do inimigo --> 350 pixels
// 10 pixels de espaço
// 20 pixels da nave de evento especial
// 30 pixels de espaço
// 270 pixels para as fileiras inimigas se movimentarem

// Separação no pixel 349

    // zona de controle do jogador --> 150 pixels
// 30 pixels de espaço
// 50 pixels de barreira.
// 30 pixels de espaço.
// 30 pixels do jogador.
// 10 pixels de espaço.